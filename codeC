/*****************************************************
This program was produced by the
CodeWizardAVR V2.05.5 Standard
Automatic Program Generator
© Copyright 1998-2011 Pavel Haiduc, HP InfoTech s.r.l.
http://www.hpinfotech.com

Project : 
Version : 
Date    : 05/12/2020
Author  : Joao teodoro da silva filho
Company : new horizonte
Comments: 


Chip type               : ATmega48
AVR Core Clock frequency: 16,000000 MHz
Memory model            : Small
External RAM size       : 0
Data Stack size         : 128
*****************************************************/

#include <mega48.h>


/* Definições gerais       */
#define ON            1
#define OFF           0
#define GRAUS_RADIANO ((2 * PI)/360)
#define RELACAO_VF    (60/220)
#define FATOR         128
#define LIMITE_FREQ   20
#define FATOR_VBAT    2.663
#define FATOR_DRIVE   0.922
#define FATOR_IAC     0.511
#define CARREGADA     0x80  
#define EM_CARGA      0x40
#define DESCARREGADA  0

/* Definições do Hardware  */
// Entradas
#define LMT_INF  PIND.0    // Limite inferior
#define BOT_RES  PIND.1    // Botão de resgate
#define JMP_DIR  PIND.2    // Jumper do motor de 3CV
#define PWR_FAIL PINB.0    // Sinal de falta de alimentação

// Saídas
#define RELE_JUMP   PORTB.5   // Relé de jumper do shunt de pré-carga dos capacitores dos drives
#define RELE_MAIN   PORTB.4   // Relé principal Alimenta os drives.
#define RELE_CHARGE PORTB.3   // Relé de carga das baterias, ligado coloca o grupo em paralelo.
#define RELE_SENSE  PORTB.2   // Relé de alimentação do Botão de resgate e do limite inferior.
#define RELE_BREAK  PORTB.1   // Relé de acionamento do freio.
#define LED_START   PORTD.4   // Led de resgate em operação, Aceso continuo - em preparação, Piscando - em tracionamento.
#define LED_BAT_OK  PORTD.7   // Led de Carga das baterias, Aceso continuo baterias carregadas, Piscando baterias em carga.


#define FIRST_ADC_INPUT 0
#define LAST_ADC_INPUT 5
unsigned int adc_data[LAST_ADC_INPUT-FIRST_ADC_INPUT+1];
#define ADC_VREF_TYPE 0xC0

#define I_AC  adc_data[0]  // Corrente do motor.
#define V_U1  adc_data[1]  // Tensão na fase U1.
#define V_V1  adc_data[2]  // Tensão na fase V1.
#define V_W1  adc_data[3]  // Tensão na fase W1.
#define V_BAT adc_data[4]  // Tensão da bateria durante a carga.
#define V_MOT adc_data[5]  // Tensão geral das baterias.


static unsigned int  ANGULO_U;
static unsigned int  ANGULO_V;
static unsigned int  ANGULO_W;
static unsigned int  VU1;
static unsigned int  VV1;
static unsigned int  VW1;
static unsigned int  IAC;



static unsigned char SINE_U;
static unsigned char SINE_V;
static unsigned char SINE_W;


static unsigned int  COUNT_TMR;
static unsigned int  TMR_DELAY;
static unsigned char STATUS_BAT;
static unsigned char TMR_LED;
static unsigned char LD_LED;
static unsigned char ERRO;
static unsigned char DEB_LMT;
static unsigned char DEB_RES;
static unsigned char DEB_PWR;

struct
{
     unsigned fstart_v   :1;
     unsigned fstart_w   :1;
     unsigned frdadc     :1;
     unsigned factangulo :1;
     unsigned fzero      :1;  
     unsigned fact_vu1   :1;
     unsigned fact_vv1   :1;
     unsigned fact_vw1   :1;  
     unsigned fsinc      :1;    
     unsigned flmtinf    :1;
     unsigned fbotres    :1;
     unsigned fpwrfail   :1;
} flags;





unsigned char STATE; // Variavel de estado de processamento.
static float GAIN; 

// ADC interrupt service routine
// with auto input scanning
interrupt [ADC_INT] void adc_isr(void)
{
     static unsigned char input_index = 0;
     // Read the AD conversion result
     adc_data[input_index] = ADCW;
     // Select next ADC input
     if(++input_index > (LAST_ADC_INPUT-FIRST_ADC_INPUT)) 
        { 
           input_index = 0;
           flags.frdadc = 1;
        }
     ADMUX = (FIRST_ADC_INPUT | (ADC_VREF_TYPE & 0xff)) +input_index;
     // Delay needed for the stabilization of the ADC input voltage
     //  delay_us(10);
     // Start the AD conversion
     ADCSRA |= 0x40;   
     if(ANGULO_U == 90) 
        { 
           VU1 = V_U1; 
           IAC = I_AC; 
           flags.fact_vu1 = 1;
        }
     if(ANGULO_V == 90) 
        {
           VV1 = V_V1;
           IAC = I_AC;  
           flags.fact_vv1 = 1;
        }
     if(ANGULO_W == 90) 
        {
           VW1 = V_W1;   
           IAC = I_AC; 
           flags.fact_vw1 = 1;
        }
}


const unsigned char SINE_TABLE[180] =  { 0x00,0x03,0x05,0x05,0x07,0x0A,0x0C,0x0E,0x10,0x12,   //  00...09
                                         0x15,0x17,0x19,0x1B,0x1D,0x1F,0x22,0x24,0x26,0x28,   //  10...19
                                         0x2A,0x2C,0x2E,0x30,0x32,0x34,0x36,0x38,0x3A,0x3C,   //  20...29
                                         0x3E,0x40,0x42,0x44,0x46,0x47,0x49,0x4B,0x4D,0x4E,   //  30...39
                                         0x50,0x52,0x53,0x55,0x57,0x58,0x5A,0x5B,0x5D,0x5E,   //  40...49
                                         0x60,0x61,0x63,0x64,0x65,0x67,0x68,0x69,0x6A,0x6B,   //  50...59
                                         0x6C,0x6E,0x6F,0x70,0x71,0x72,0x73,0x73,0x74,0x75,   //  60...69                                          
                                         0x76,0x77,0x77,0x78,0x79,0x79,0x7A,0x7A,0x7B,0x7B,   //  70...69
                                         0x7C,0x7C,0x7C,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,   //  80...69
                                         0x7E,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7C,0x7C,   //  90...69
                                         0x7C,0x7B,0x7B,0x7A,0x7A,0x79,0x79,0x78,0x77,0x77,   // 100...109
                                         0x76,0x75,0x74,0x73,0x73,0x72,0x71,0x70,0x6F,0x6E,   // 110...119
                                         0x6C,0x6B,0x6A,0x69,0x68,0x67,0x65,0x64,0x63,0x61,   // 120...129
                                         0x60,0x5E,0x5D,0x5B,0x5A,0x58,0x57,0x55,0x53,0x52,   // 130...139
                                         0x50,0x4E,0x4D,0x4B,0x49,0x47,0x46,0x44,0x42,0x40,   // 140...149
                                         0x3E,0x3C,0x3A,0x38,0x36,0x34,0x32,0x30,0x2E,0x2C,   // 150...159
                                         0x2A,0x28,0x26,0x24,0x22,0x1F,0x1D,0x1B,0x19,0x17,   // 160...169
                                         0x15,0x12,0x10,0x0E,0x0C,0x0A,0x07,0x05,0x03,0x01 }; // 170...179      
// Timer1 overflow interrupt service routine
interrupt [TIM1_OVF] void timer1_ovf_isr(void)
{
// Reinitialize Timer1 value
     TCNT1H = 0xF4;
     TCNT1L = 0x6D; 
     if(STATE == 6)
        {
           if((flags.fpwrfail) && (!flags.flmtinf) && (!flags.fbotres))
              {
                 flags.factangulo = 1; 
                 if(JMP_DIR)
                    {         
                       OCR0A  = SINE_U; 
                       OCR0B  = SINE_V;  
                       OCR2B  = SINE_W; 
                    }  
                 else
                    {         
                       OCR0A  = SINE_W; 
                       OCR0B  = SINE_V;  
                       OCR2B  = SINE_U; 
                    }        
                 ANGULO_U++; 
                 if(ANGULO_U > 119) flags.fstart_v = 1;     
                 if(ANGULO_U > 359) 
                    {
                       ANGULO_U = 0; 
                       flags.fzero = 1;
                    }   
                 if(flags.fstart_v)
                    {
                       ANGULO_V++;      
                       if(ANGULO_V > 119) flags.fstart_w = 1;
                       if(ANGULO_V > 359) { ANGULO_V = 0; flags.fstart_v = 0; }  
                    }
                 if(flags.fstart_w)
                    {
                       ANGULO_W++;  
                      if(ANGULO_W > 359) { ANGULO_W = 0; flags.fstart_w = 0; }
                    }           
              }
           else
              {
                 OCR0A = 0;
                 OCR0B = 0;
                 OCR2B = 0;  
                 flags.fstart_v = 0;  
                 flags.fstart_w = 0;
                 ANGULO_U = 0;
                 ANGULO_V = 0;
                 ANGULO_W = 0;  
              }
        } 
     else
        {
           OCR0A = 0;
           OCR0B = 0;
           OCR2B = 0; 
           ANGULO_U = 0;
           ANGULO_V = 0;
           ANGULO_W = 0;  
        }
     flags.fsinc  = 1;
}


void initParam(void);   
void Temporizadores(void);
                                         
void main(void)
{
     // Declare your local variables here

// Crystal Oscillator division factor: 1
#pragma optsize-
CLKPR=0x80;
CLKPR=0x00;
#ifdef _OPTIMIZE_SIZE_
#pragma optsize+
#endif

     // Reset Source checking
     if(MCUSR & 1) initParam();     
     else if(MCUSR & 2) initParam();
     else if(MCUSR & 4) initParam();
     else initParam();
     MCUSR = 0;
// Input/Output Ports initialization
// Port B initialization
// Func7=In Func6=In Func5=Out Func4=Out Func3=Out Func2=Out Func1=Out Func0=In 
// State7=T State6=T State5=0 State4=0 State3=0 State2=0 State1=0 State0=P 
     PORTB = 0x01;
     DDRB  = 0x3E;
// Port C initialization
// Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In 
// State6=T State5=T State4=T State3=T State2=T State1=T State0=T 
     PORTC = 0x00;
     DDRC  = 0x00;
// Port D initialization
// Func7=Out Func6=Out Func5=Out Func4=Out Func3=Out Func2=In Func1=In Func0=In 
// State7=0 State6=0 State5=0 State4=0 State3=0 State2=P State1=P State0=P 
     PORTD = 0x07;
     DDRD  = 0xF8;
// Timer/Counter 0 initialization
// Clock source: System Clock
// Clock value: 2000,000 kHz
// Mode: Phase correct PWM top=0xFF
// OC0A output: Non-Inverted PWM
// OC0B output: Non-Inverted PWM
TCCR0A=0xA1;
TCCR0B=0x02;
TCNT0=0x00;
OCR0A=0x00;
OCR0B=0x00;
// Timer/Counter 1 initialization
// Clock source: System Clock
// Clock value: 16000,000 kHz
// Mode: Normal top=0xFFFF
// OC1A output: Discon.
// OC1B output: Discon.
// Noise Canceler: Off
// Input Capture on Falling Edge
// Timer1 Overflow Interrupt: On
// Input Capture Interrupt: Off
// Compare A Match Interrupt: Off
// Compare B Match Interrupt: Off
     TCCR1A = 0x00;
     TCCR1B = 0x01;
     TCNT1H = 0xF4;
     TCNT1L = 0x6D;
     ICR1H  = 0x00;
     ICR1L  = 0x00;
     OCR1AH = 0x00;
     OCR1AL = 0x00;
     OCR1BH = 0x00;
     OCR1BL = 0x00;
// Timer/Counter 2 initialization
// Clock source: System Clock
// Clock value: 2000,000 kHz
// Mode: Phase correct PWM top=0xFF
// OC2A output: Disconnected
// OC2B output: Non-Inverted PWM
ASSR=0x00;
TCCR2A=0x21;
TCCR2B=0x02;
TCNT2=0x00;
OCR2A=0x00;
OCR2B=0x00;
// External Interrupt(s) initialization
// INT0: Off
// INT1: Off
// Interrupt on any change on pins PCINT0-7: Off
// Interrupt on any change on pins PCINT8-14: Off
// Interrupt on any change on pins PCINT16-23: Off
     EICRA  = 0x00;
     EIMSK  = 0x00;
     PCICR  = 0x00;
// Timer/Counter 0 Interrupt(s) initialization
     TIMSK0 = 0x00;
// Timer/Counter 1 Interrupt(s) initialization
     TIMSK1 = 0x01;
// Timer/Counter 2 Interrupt(s) initialization
     TIMSK2 = 0x00;
// USART initialization
// USART disabled
     UCSR0B = 0x00;
// Analog Comparator initialization
// Analog Comparator: Off
// Analog Comparator Input Capture by Timer/Counter 1: Off
     ACSR   = 0x80;
     ADCSRB = 0x00;
     DIDR1  = 0x00;  
// ADC initialization
// ADC Clock frequency: 1000,000 kHz
// ADC Voltage Reference: Int., cap. on AREF
// ADC Auto Trigger Source: Timer1 Overflow
// Digital input buffers on ADC0: Off, ADC1: Off, ADC2: Off, ADC3: Off
// ADC4: Off, ADC5: Off
     DIDR0   = 0x3F;
     ADMUX   = FIRST_ADC_INPUT | (ADC_VREF_TYPE & 0xff);
     ADCSRA  = 0xAC;
     ADCSRB &= 0xF8;
     ADCSRB |= 0x06;
// SPI initialization
// SPI disabled
     SPCR   = 0x00;
// TWI initialization
// TWI disabled
     TWCR   = 0x00;
// Global enable interrupts
     #asm("sei")
     while(1)
        {     
           switch(STATE)
              {
                 case 0:  if(!flags.fpwrfail)
                             {            
                                 GAIN = 0;    
                                 LED_START = ON;
                                 if(V_BAT >= 764) 
                                    { 
                                       STATUS_BAT = CARREGADA;
                                       if(ERRO == 1) ERRO = 0;   
                                    }
                                 else if((V_BAT >= 527) && (V_BAT < 764)) 
                                    { 
                                       STATUS_BAT = EM_CARGA; 
                                       LD_LED = 765 - V_BAT;
                                       if(LD_LED > 30) LD_LED = 30;
                                       if(ERRO == 1) ERRO = 0;
                                    }
                                 else STATUS_BAT = DESCARREGADA;    
                                 RELE_BREAK = ON;
                             }
                          else  
                             {
                                TMR_DELAY = 30;
                                STATE = 1;
                             } 
                          break;      
                          
                 case 1:  if(flags.fpwrfail)
                             {  
                                if(TMR_DELAY == 0)
                                   {
                                      RELE_BREAK = OFF;  
                                      TMR_DELAY  = 20;
                                      STATE = 2; 
                                   }
                             }   
                          else STATE = 0;
                          break;
                           
                 case 2:  if(flags.fpwrfail)
                             {  
                                if(TMR_DELAY == 0)
                                   {
                                      RELE_SENSE = ON;  
                                      TMR_DELAY  = 10;
                                      STATE = 3; 
                                   }
                             }   
                          else STATE = 10;
                          break;      
                          
                 case 3:  if(flags.fpwrfail)
                             {  
                                if(TMR_DELAY == 0)
                                   {
                                      if(!flags.flmtinf) 
                                         { 
                                            RELE_MAIN = ON;   
                                            TMR_DELAY = 10;
                                            STATE = 4;
                                         } 
                                      else STATE = 10; 
                                   }
                             }   
                          else STATE = 10;
                          break;   
                          
                 case 4:  if((flags.fpwrfail) && (!flags.flmtinf))
                             {      
                                RELE_JUMP = ON;
                                TMR_DELAY = 10;
                                STATE = 5; 
                             }  
                          else STATE = 10;
                          break; 
                             
                 case 5:  if((flags.fpwrfail) && (!flags.flmtinf))
                             {
                                if(TMR_DELAY == 0) STATE = 6;
                             }
                           else STATE = 10;
                           break;
                 case 6:   if((flags.fpwrfail) && (!flags.flmtinf))
                             {
                                if(!flags.fbotres)
                                   {                      
                                      LED_START = OFF;
                                      if(flags.factangulo)
                                         {            
                                            flags.factangulo = 0;    
                                            if(flags.fzero)  
                                               {
                                                  if(GAIN < .85) GAIN = GAIN + .05;    
                                                  flags.fzero = 0;
                                               }   
                                            if(ANGULO_U < 180) SINE_U = (SINE_TABLE[ANGULO_U] + 127) * GAIN;
                                            else SINE_U = (128 - SINE_TABLE[(ANGULO_U - 180)]) * GAIN;   
                                            if(ANGULO_V < 180) SINE_V = (SINE_TABLE[ANGULO_V] + 127) * GAIN;
                                            else SINE_V = (128 - SINE_TABLE[(ANGULO_V - 180)]) * GAIN;   
                                            if(ANGULO_W < 180) SINE_W = (SINE_TABLE[ANGULO_W] + 127) * GAIN;
                                            else SINE_W = (128 - SINE_TABLE[(ANGULO_W - 180)]) * GAIN;   
                                         }
                                   } 
                                else
                                   { 
                                      SINE_U = 0;
                                      SINE_V = 0;
                                      SINE_W = 0;  
                                      GAIN = 0;   
                                      LED_START = ON;
                                      flags.fzero = 0;
                                      flags.factangulo = 0;
                                   }
                             }   
                          else 
                             {       
                                SINE_U = 0;
                                SINE_V = 0;
                                SINE_W = 0;  
                                GAIN = 0;   
                                LED_START = ON;
                                flags.fzero = 0;
                                flags.factangulo = 0;
                                STATE = 10; 
                             }
                           break;
                               
                 case 10: if(!flags.fpwrfail)
                             {
                                 RELE_MAIN = OFF;
                                 RELE_JUMP = OFF;   
                                 RELE_SENSE = OFF;  
                                 SINE_U = 0;
                                 SINE_V = 0;
                                 SINE_W = 0;
                                 TMR_DELAY = 20;
                                 STATE = 11;
                             }  
                          break; 
                 case 11: if(TMR_DELAY == 0)  STATE = 0;
                          break;
                                         
                          
                }  
           if(flags.fsinc) 
              {                   
                 flags.fsinc = 0;
                 if(COUNT_TMR > 0) COUNT_TMR--;
                 else
                    {
                       COUNT_TMR = 540;    
                       Temporizadores();
                    }
              }
        }
}
void initParam(void)
{
     COUNT_TMR  = 540; 
     DEB_RES = 5;
     DEB_LMT = 5;
     DEB_PWR = 5; 
     ERRO    = 0;  
     TMR_LED = 0;
     SINE_U = 0;
     SINE_V = 0; 
     SINE_W = 0; 
     GAIN   = 0;
     flags.fstart_v = 0;
     flags.fstart_w = 0;
     flags.factangulo = 0;
     flags.fzero = 0;
     OCR0A  = 0;
     OCR0B  = 0;
     OCR2A  = 0;  
     RELE_MAIN  = OFF;
     RELE_JUMP  = OFF;
     RELE_SENSE = OFF;  
     RELE_BREAK = OFF;
     RELE_CHARGE = ON;  
     LED_START   = ON;
     I_AC  = 0;
     V_U1  = 0;
     V_V1  = 0;
     V_W1  = 0;
     V_BAT = 0;
     V_MOT = 0; 
     STATE = 0;
}
void Temporizadores(void)
{
     if(ERRO == 0)
        {
           if(STATUS_BAT == CARREGADA) LED_BAT_OK = OFF;
           else if(STATUS_BAT == EM_CARGA)
              {
                 if(LED_BAT_OK) 
                    {
                       if(TMR_LED > 0) TMR_LED--;
                       else
                          {
                             TMR_LED = 1;
                             LED_BAT_OK = OFF;
                          }
                    }
                 else
                    {
                       if(TMR_LED > 0) TMR_LED--;
                       else
                          {
                             TMR_LED = LD_LED; 
                             LED_BAT_OK = ON;
                          }
                    }       
              }
           else if(STATUS_BAT == DESCARREGADA)
              {       
                 if(TMR_LED > 0) TMR_LED--;
                 else
                    {     
                       TMR_LED = 2;
                       LED_BAT_OK = !LED_BAT_OK;
                    }
              }
           else LED_BAT_OK = ON;
        }
     else if(ERRO == 1)
        {
           if(TMR_LED > 0) TMR_LED--;
           else
              {      
                 TMR_LED = 2;
                 LED_BAT_OK = !LED_BAT_OK;
                // LED_START  = LED_BAT_OK;     
              }
        }
     else
        {
          if(TMR_LED > 0) TMR_LED--;
           else
              {      
                 TMR_LED = 2;
                 LED_BAT_OK = !LED_BAT_OK;
                // LED_START  = !LED_BAT_OK;     
              }
        }        
     if(TMR_DELAY > 0) TMR_DELAY--;    
     if((LMT_INF) && (!flags.flmtinf))                                             
        {       
           if(DEB_LMT > 0) DEB_LMT--; 
           else flags.flmtinf = 1; 
        } 
     else if((!LMT_INF) && (flags.flmtinf)) 
        {     
           if(DEB_LMT > 0) DEB_LMT--; 
           else flags.flmtinf = 0; 
        }  
     else DEB_LMT = 5; 
     if((BOT_RES) && (!flags.fbotres))                                             
        {       
           if(DEB_RES > 0) DEB_RES--; 
           else flags.fbotres = 1; 
        } 
     else if((!BOT_RES) && (flags.fbotres))
        {     
           if(DEB_RES > 0) DEB_RES--; 
           else flags.fbotres = 0; 
        } 
     else BOT_RES = 5;           
     if((PWR_FAIL) && (!flags.fpwrfail))                                             
        {       
           if(DEB_PWR > 0) DEB_PWR--; 
           else flags.fpwrfail = 1; 
        } 
     else if((!PWR_FAIL) && (flags.fpwrfail))
        {     
           if(DEB_PWR > 0) DEB_PWR--; 
           else flags.fpwrfail = 0; 
        }   
     else DEB_PWR = 5;                   
}    
